/**
 * BrainRex API
 * The Brainrex API is a collection of analytics tools and data integrations made for blockchain developers. In particular we offer Natural Language Processing and Anomaly detection algorithms that have been fine tune to understand text data and time series in the domain speficic setting of cryptocurrency and blockchain technology. This technology is intended to be use as building blocks to bigger applications, we offer examples on how to use them for Trading Backtesting and Smart Contract anomaly monitoring.
 *
 * OpenAPI spec version: 1.0.2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package brainrex;

import io.swagger.client.ApiInvoker;
import io.swagger.client.ApiException;
import io.swagger.client.Pair;

import brainrexPackage.*;

import java.util.*;

import com.android.volley.Response;
import com.android.volley.VolleyError;

import brainrexPackage.CandleRequest;
import brainrexPackage.CandleResponse;
import brainrexPackage.Exchange;
import brainrexPackage.ExchangeAssetsResponse;
import brainrexPackage.OrderbookRequest;
import brainrexPackage.OrderbookResponse;
import brainrexPackage.SupportedExchanges;
import brainrexPackage.TickerResponse;

import org.apache.http.HttpEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

public class IntegrationsApi {
  String basePath = "https://api.bitlongs.com";
  ApiInvoker apiInvoker = ApiInvoker.getInstance();

  public void addHeader(String key, String value) {
    getInvoker().addDefaultHeader(key, value);
  }

  public ApiInvoker getInvoker() {
    return apiInvoker;
  }

  public void setBasePath(String basePath) {
    this.basePath = basePath;
  }

  public String getBasePath() {
    return basePath;
  }

  /**
  * Downloads candle format market data
  * Returns a list of candle data from specified market and data range
   * @param candleRequest The Get candles end point return market data in Open High Close Volume format. In order to use this endpoint you need to enter your API keys to your data provider in the console
   * @return CandleResponse
  */
  public CandleResponse cryptoGetCandleData (CandleRequest candleRequest) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = candleRequest;
    // verify the required parameter 'candleRequest' is set
    if (candleRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'candleRequest' when calling cryptoGetCandleData",
        new ApiException(400, "Missing the required parameter 'candleRequest' when calling cryptoGetCandleData"));
    }

    // create path and map variables
    String path = "/crypto/get_candles";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "APIKeyHeader" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (CandleResponse) ApiInvoker.deserialize(localVarResponse, "", CandleResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Downloads candle format market data
   * Returns a list of candle data from specified market and data range
   * @param candleRequest The Get candles end point return market data in Open High Close Volume format. In order to use this endpoint you need to enter your API keys to your data provider in the console
  */
  public void cryptoGetCandleData (CandleRequest candleRequest, final Response.Listener<CandleResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = candleRequest;

    // verify the required parameter 'candleRequest' is set
    if (candleRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'candleRequest' when calling cryptoGetCandleData",
        new ApiException(400, "Missing the required parameter 'candleRequest' when calling cryptoGetCandleData"));
    }

    // create path and map variables
    String path = "/crypto/get_candles".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "APIKeyHeader" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((CandleResponse) ApiInvoker.deserialize(localVarResponse,  "", CandleResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Gets all coin pairs traded in specified exchange
  * This endpoint returns all the Available currency pairs
   * @param exchange Name of the cryptocurrency exchange
   * @return ExchangeAssetsResponse
  */
  public ExchangeAssetsResponse cryptoGetExchangeAssets (Exchange exchange) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = exchange;
    // verify the required parameter 'exchange' is set
    if (exchange == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'exchange' when calling cryptoGetExchangeAssets",
        new ApiException(400, "Missing the required parameter 'exchange' when calling cryptoGetExchangeAssets"));
    }

    // create path and map variables
    String path = "/crypto/get_exchange_assets";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "APIKeyHeader" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ExchangeAssetsResponse) ApiInvoker.deserialize(localVarResponse, "", ExchangeAssetsResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Gets all coin pairs traded in specified exchange
   * This endpoint returns all the Available currency pairs
   * @param exchange Name of the cryptocurrency exchange
  */
  public void cryptoGetExchangeAssets (Exchange exchange, final Response.Listener<ExchangeAssetsResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = exchange;

    // verify the required parameter 'exchange' is set
    if (exchange == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'exchange' when calling cryptoGetExchangeAssets",
        new ApiException(400, "Missing the required parameter 'exchange' when calling cryptoGetExchangeAssets"));
    }

    // create path and map variables
    String path = "/crypto/get_exchange_assets".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "APIKeyHeader" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ExchangeAssetsResponse) ApiInvoker.deserialize(localVarResponse,  "", ExchangeAssetsResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Returns the current state of the orderbook.
  * This endpoint returns the current state of the ordebook with a limit set by you. The maximun orderbook depth is 25.
   * @param orderbookRequest Exchange, trading pair and date rage for data
   * @return OrderbookResponse
  */
  public OrderbookResponse cryptoGetOrderbooks (OrderbookRequest orderbookRequest) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = orderbookRequest;
    // verify the required parameter 'orderbookRequest' is set
    if (orderbookRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'orderbookRequest' when calling cryptoGetOrderbooks",
        new ApiException(400, "Missing the required parameter 'orderbookRequest' when calling cryptoGetOrderbooks"));
    }

    // create path and map variables
    String path = "/crypto/get_orderbooks";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "APIKeyHeader" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (OrderbookResponse) ApiInvoker.deserialize(localVarResponse, "", OrderbookResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Returns the current state of the orderbook.
   * This endpoint returns the current state of the ordebook with a limit set by you. The maximun orderbook depth is 25.
   * @param orderbookRequest Exchange, trading pair and date rage for data
  */
  public void cryptoGetOrderbooks (OrderbookRequest orderbookRequest, final Response.Listener<OrderbookResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = orderbookRequest;

    // verify the required parameter 'orderbookRequest' is set
    if (orderbookRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'orderbookRequest' when calling cryptoGetOrderbooks",
        new ApiException(400, "Missing the required parameter 'orderbookRequest' when calling cryptoGetOrderbooks"));
    }

    // create path and map variables
    String path = "/crypto/get_orderbooks".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "APIKeyHeader" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((OrderbookResponse) ApiInvoker.deserialize(localVarResponse,  "", OrderbookResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Gets all cryptocurrency exchanges supported by the Brainrex API
  * Returns a list of candle data from specified market and data range
   * @return SupportedExchanges
  */
  public SupportedExchanges cryptoGetSupportedExchanges () throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/crypto/get_supported_exchanges";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "APIKeyHeader" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SupportedExchanges) ApiInvoker.deserialize(localVarResponse, "", SupportedExchanges.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Gets all cryptocurrency exchanges supported by the Brainrex API
   * Returns a list of candle data from specified market and data range

  */
  public void cryptoGetSupportedExchanges (final Response.Listener<SupportedExchanges> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/crypto/get_supported_exchanges".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "APIKeyHeader" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SupportedExchanges) ApiInvoker.deserialize(localVarResponse,  "", SupportedExchanges.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Downloads candle format market data
  * Returns a list of candle data from specified market and data range
   * @param exchange Get ticker data from specified crypto exchange
   * @return TickerResponse
  */
  public TickerResponse cryptoGetTicker (Exchange exchange) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = exchange;
    // verify the required parameter 'exchange' is set
    if (exchange == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'exchange' when calling cryptoGetTicker",
        new ApiException(400, "Missing the required parameter 'exchange' when calling cryptoGetTicker"));
    }

    // create path and map variables
    String path = "/crypto/get_ticker";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "APIKeyHeader" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (TickerResponse) ApiInvoker.deserialize(localVarResponse, "", TickerResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Downloads candle format market data
   * Returns a list of candle data from specified market and data range
   * @param exchange Get ticker data from specified crypto exchange
  */
  public void cryptoGetTicker (Exchange exchange, final Response.Listener<TickerResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = exchange;

    // verify the required parameter 'exchange' is set
    if (exchange == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'exchange' when calling cryptoGetTicker",
        new ApiException(400, "Missing the required parameter 'exchange' when calling cryptoGetTicker"));
    }

    // create path and map variables
    String path = "/crypto/get_ticker".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "APIKeyHeader" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((TickerResponse) ApiInvoker.deserialize(localVarResponse,  "", TickerResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
}
